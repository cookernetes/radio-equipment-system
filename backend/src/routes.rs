use std::env;use std::str::FromStr;use actix_web::{get, Responder, HttpResponse, web, patch, post};use futures::stream::{StreamExt, TryStreamExt};use std::sync::Arc;use mongodb::bson::doc;use mongodb::bson::oid::{Error, ObjectId};use mongodb::{bson, Database};use serde::{Deserialize, Serialize};use crate::models::item_model::{Item, ItemStatus};use crate::models::user_model::{User, UserRawPhysicalToken};#[get("/ping")]async fn ping_test_route() -> impl Responder {    HttpResponse::ImATeapot().body("Pong!")}// TODO: Route guard.#[get("/user-qr/{user_id}")]async fn ret_user_id_qr(db: web::Data<Arc<Database>>, path: web::Path<String>) -> impl Responder {    let user_id = path.into_inner();    let user_id: ObjectId = match ObjectId::from_str(&user_id) {        Ok(object_id) => object_id,        Err(_) => return HttpResponse::BadRequest().into()    };    let collection = db.collection::<User>("users");    match collection.find_one(doc! {"_id": user_id}, None).await {        Ok(None) => HttpResponse::NotFound().into(),        Ok(user) => {            HttpResponse::Ok().body(user.unwrap().physical_id_qr_token)        },        Err(_) => HttpResponse::InternalServerError().into()    }}#[derive(Serialize, Deserialize)]struct LoginRouteBody {    /**    User's 6 digit passcode.    */    numeric_password: u8,    /**    User's ID BRANCA token string    */    id_token: UserRawPhysicalToken,    /**    User's ID    */    user_id: ObjectId}#[post("/login")]async fn login(db: web::Data<Arc<Database>>, body: web::Json<LoginRouteBody>) -> impl Responder {    let LoginRouteBody {id_token, numeric_password, user_id} = body;    let collection = db.collection::<User>("users");    /*    Data validity check works by checking first the password matches the hash,    then the password and username stored inside of the user's ID token is also checked.    If all is not good, a forbidden/403 error is returned.    If all is good, then it will create and return a short-lived session token which will allow the    user to perform backend actions like e.g. borrow an item, or put one back (non persistent token    is only for the standard user part of the application).    */    // Get user pass hash from DB via user ID    let user: User = collection.find_one(doc! { "_id": body.item_id }, None)        .await        .unwrap()        .unwrap_or_else(HttpResponse::NotFound());    let parsed_id_token: _ = match branca::decode(user.physical_id_qr_token.as_str(), env::var("BRANCA_KEY").unwrap().as_ref(), 0) {        Ok(token) => String::from_utf8(token).unwrap(),        Err(_) => HttpResponse::Unauthorized().into()    };    println!("{}", parsed_id_token);    HttpResponse::ImATeapot()    // Password Check    /*let password_validity = bcrypt::verify(numeric_password, &user.pass_hash).unwrap_or_else(HttpResponse::InternalServerError());    if !password_validity || id_token.pass_hash != user.physical_id_qr_token.pass_hash || id_token.username != user.username {        HttpResponse::Unauthorized()    }*/    // Make and store a new short-lived session (token) and return it in the response body}#[get("/items")]async fn get_all_items(db: web::Data<Arc<Database>>) -> impl Responder {    let collection = db.collection::<Item>("items");    let items_cursor = collection.find(None, None).await.unwrap();    let items: Vec<Result<_, _>> = items_cursor.collect().await;    let unwrapped_items: _ = items.into_iter().flatten().collect::<Vec<_>>();    HttpResponse::Ok().json(unwrapped_items)}#[derive(Serialize, Deserialize)]struct ChangeItemStatusRequestBody {    item_id: ObjectId,    new_status: ItemStatus,}#[patch("/change-item-status")]async fn change_item_status(db: web::Data<Arc<Database>>, body: web::Json<ChangeItemStatusRequestBody>) -> impl Responder {    let collection = db.collection::<Item>("items");    let update_result = collection.update_one(        doc! {            "_id": body.item_id        },        doc! {            "$set": {                "status": bson::to_bson(&body.new_status).unwrap()            }        },        None,    ).await.unwrap();    if update_result.matched_count == 0 {        HttpResponse::NotFound().body("Error: No documents found to modify.")    } else {        HttpResponse::Ok().into()    }}// TODO: Below#[get("/simple-stats")]async fn get_simple_stats(db: web::Data<Arc<Database>>) -> impl Responder {    return HttpResponse::InternalServerError();    todo!();}